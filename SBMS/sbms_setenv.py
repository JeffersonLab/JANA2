from __future__  import print_function, absolute_import, division


#####################################################################
# This file is used to generate a setenv.csh script in the installation
# directory that can be used to setup one's environment to use the
# programs and libraries installed there. This takes the place of the
# mk_setenv.csh script in the Hall-D scripts directory.
#
# This should get called anytime the user specifies the "install" target
# on the command line. e.g.:
#
#  scons -u install
#
# It is called from the bottom of the top-level SConstruct file
#
# Nov. 5, 2013  DL
#####################################################################


import os, sys
import subprocess
import datetime
from stat import *


##################################
# mk_setenv_csh
##################################
def mk_setenv_csh(env):
	ofdir = '%s' % env.Dir(env['INSTALLDIR'])
	ofname = '%s/setenv.csh' % ofdir
	print('sbms : Making setenv.csh in %s' % ofdir)

	str = ''

	# Header
	str += '#!/bin/tcsh\n'
	str += '#\n'
	str += '# This file was generated by the SBMS system (see SBMS/sbms_setenv.py)\n'
	str += '#\n'
	str += '# Generation date: %s\n' % datetime.datetime.now().strftime("%I:%M%p on %B %d, %Y")
	str += '#\n'
	str += '#       User: %s\n' % os.getenv('USER', 'Unknown')
	str += '#       Host: %s\n' % os.getenv('HOST', 'Unknown')
	str += '#   platform: %s' % subprocess.Popen(["uname", "-a"], stdout=subprocess.PIPE).communicate()[0]
	str += '# BMS_OSNAME: %s\n' % env['OSNAME']
	str += '\n'
	str += '\n'

	# (DY)LD_LIBRARY_PATH
	# On BSD systems, DYLD_LIBRARY_PATH is used while on most others
	# (including Linux) LD_LIBRARY_PATH is used. Here, we set the LDLPV
	# variable to name of the variable to set. We determine this by whether
	# or not DYLD_LIBRARY_PATH is set. At the same time, we make sure the
	# variable is at least defined (empty if needed) so the rest of the
	# generated script can just add to it without checking for existence.
	LDLPV='LD_LIBRARY_PATH'
	if os.getenv('DYLD_LIBRARY_PATH', 'unset') != 'unset': LDLPV='DYLD_LIBRARY_PATH'

	str += '# Make sure %s is set\n' % LDLPV
	str += 'if ( ! $?%s ) then\n' % LDLPV
	str += '   setenv %s\n' % LDLPV
	str += 'endif\n'
	str += '\n'

	# CLANG-LLVM C++ compiler
	# If the CLANGROOT environment variable is set, check if there is
	# a setenv.csh script in there that we can source.
	clangroot = os.getenv('CLANGROOT')
	if clangroot != None:
		if os.path.isfile(clangroot):
			str += '# CLANG-LLVM C++ compiler\n'
			str += 'if ( -e %s/setenv.csh ) then\n' % clangroot
			str += '  source %s/setenv.csh\n' % clangroot
			str += 'endif\n'
			str += '\n'
	
	# JANA
	str += '# JANA\n'
	str += 'setenv JANA_HOME %s\n' % env.Dir(env['INSTALLDIR']).srcnode().abspath
	str += 'setenv JANA_CALIB_URL %s\n' % os.getenv('JANA_CALIB_URL', '$HOME/halld/calib')
	str += 'if ( $?HDDS_HOME ) then\n'
	str += '  setenv JANA_GEOMETRY_URL xmlfile://${HDDS_HOME}/main_HDDS.xml\n'
	str += 'endif\n'
	str += 'setenv JANA_PLUGIN_PATH ${JANA_HOME}/plugins\n'
	str += 'setenv PATH ${JANA_HOME}/bin:${PATH}\n'
	str += '\n'

	# CCDB
	ccdb_home = os.getenv('CCDB_HOME')
	if ccdb_home != None:
		str += '# CCDB\n'
		str += 'setenv CCDB_HOME %s\n' % os.getenv('CCDB_HOME', '$HOME/ccdb')
		str += 'if ( -e $CCDB_HOME/environment.csh ) then\n'
		str += '  source $CCDB_HOME/environment.csh\n'
		str += 'endif\n'
		str += 'setenv CCDB_CONNECTION ${JANA_CALIB_URL}\n'
		str += '\n'

	# ROOT
	rootsys = os.getenv('ROOTSYS')
	if rootsys != None:
		str += '# ROOT\n'
		str += 'setenv ROOTSYS %s\n' % rootsys
		str += 'setenv PATH ${ROOTSYS}/bin:${PATH}\n'
		str += 'setenv %s ${ROOTSYS}/lib:${%s}\n' % (LDLPV, LDLPV)
		str += '\n'

	# Xerces
	xercescroot = os.getenv('XERCESCROOT')
	if xercescroot != None:
		str += '# Xerces\n'
		str += 'setenv XERCESCROOT %s\n' % xercescroot
		str += 'setenv PATH ${XERCESCROOT}/bin:${PATH}\n'
		str += 'setenv %s ${XERCESCROOT}/lib:${%s}\n' % (LDLPV, LDLPV)
		str += '\n'

	# Make sure output directory eists
	try:
		os.mkdir(ofdir)
	except OSError:
		pass

	# Write to file
	f = open(ofname, 'w')
	f.write(str)
	f.close()
	os.chmod(ofname, S_IRWXU + S_IRGRP + S_IXGRP + S_IROTH + S_IXOTH)


##################################
# mk_setenv_bash
##################################
def mk_setenv_bash(env):
	ofdir = '%s' % env.Dir(env['INSTALLDIR'])
	ofname = '%s/setenv.sh' % ofdir
	print('sbms : Making setenv.sh in %s' % ofdir)

	str = ''

	# Header
	str += '#!/bin/sh\n'
	str += '#\n'
	str += '# This file was generated by the SBMS system (see SBMS/sbms_setenv.py)\n'
	str += '#\n'
	str += '# Generation date: %s\n' % datetime.datetime.now().strftime("%I:%M%p on %B %d, %Y")
	str += '#\n'
	str += '#       User: %s\n' % os.getenv('USER', 'Unknown')
	str += '#       Host: %s\n' % os.getenv('HOST', 'Unknown')
	str += '#   platform: %s' % subprocess.Popen(["uname", "-a"], stdout=subprocess.PIPE).communicate()[0]
	str += '# BMS_OSNAME: %s\n' % env['OSNAME']
	str += '\n'
	str += '\n'

	# (DY)LD_LIBRARY_PATH
	# On BSD systems, DYLD_LIBRARY_PATH is used while on most others
	# (including Linux) LD_LIBRARY_PATH is used. Here, we set the LDLPV
	# variable to name of the variable to set. We determine this by whether
	# or not DYLD_LIBRARY_PATH is set. At the same time, we make sure the
	# variable is at least defined (empty if needed) so the rest of the
	# generated script can just add to it without checking for existence.
	LDLPV='LD_LIBRARY_PATH'
	if os.getenv('DYLD_LIBRARY_PATH', 'unset') != 'unset': LDLPV='DYLD_LIBRARY_PATH'

	str += '# Make sure %s is set\n' % LDLPV
	str += 'if [ -z "$%s" ]; then\n' % LDLPV
	str += '   export %s=""\n' % LDLPV
	str += 'fi\n'
	str += '\n'

	# CLANG-LLVM C++ compiler
	# If the CLANGROOT environment variable is set, check if there is
	# a setenv.csh script in there that we can source.
	clangroot = os.getenv('CLANGROOT')
	if clangroot != None:
		if os.path.isfile(clangroot):
			str += '# CLANG-LLVM C++ compiler\n'
			str += 'if [ -e %s/setenv.sh ]; then\n' % clangroot
			str += '  . %s/setenv.sh\n' % clangroot
			str += 'fi\n'
			str += '\n'
	
	# JANA
	str += '# JANA\n'
	str += 'export JANA_HOME=%s\n' % env.Dir(env['INSTALLDIR']).srcnode().abspath
	str += 'export JANA_CALIB_URL=%s\n' % os.getenv('JANA_CALIB_URL', '$HOME/halld/calib')
	str += '[ ! -z "$HDDS_HOME" ] && export JANA_GEOMETRY_URL=xmlfile://${HDDS_HOME}/main_HDDS.xml\n'
	str += 'export JANA_PLUGIN_PATH=${JANA_HOME}/plugins\n'
	str += 'export PATH=${JANA_HOME}/bin:${PATH}\n'
	str += '\n'

	# CCDB
	ccdb_home = os.getenv('CCDB_HOME')
	if ccdb_home != None:
		str += '# CCDB\n'
		str += 'export CCDB_HOME=%s\n' % os.getenv('CCDB_HOME', '$HOME/ccdb')
		str += 'if [ -e $CCDB_HOME/environment.sh ]; then\n'
		str += '  . $CCDB_HOME/environment.sh\n'
		str += 'fi\n'
		str += 'export CCDB_CONNECTION=${JANA_CALIB_URL}\n'
		str += '\n'

	# ROOT
	rootsys = os.getenv('ROOTSYS')
	if rootsys != None:
		str += '# ROOT\n'
		str += 'export ROOTSYS=%s\n' % rootsys
		str += 'export PATH=${ROOTSYS}/bin:${PATH}\n'
		str += 'export %s=${ROOTSYS}/lib:${%s}\n' % (LDLPV, LDLPV)
		str += '\n'

	# Xerces
	xercescroot = os.getenv('XERCESCROOT')
	if xercescroot != None:
		str += '# Xerces\n'
		str += 'export XERCESCROOT=%s\n' % xercescroot
		str += 'export PATH=${XERCESCROOT}/bin:${PATH}\n'
		str += 'export %s=${XERCESCROOT}/lib:${%s}\n' % (LDLPV, LDLPV)
		str += '\n'

	# Make sure output directory eists
	try:
		os.mkdir(ofdir)
	except OSError:
		pass

	# Write to file
	f = open(ofname, 'w')
	f.write(str)
	f.close()
	os.chmod(ofname, S_IRWXU + S_IRGRP + S_IXGRP + S_IROTH + S_IXOTH)


